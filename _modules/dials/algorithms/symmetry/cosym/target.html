

<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dials.algorithms.symmetry.cosym.target &#8212; DIALS  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" href="../../../../../_static/dials-styles.css" type="text/css" />
    <script src="../../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../../../about.html" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="logoheader container">
  <a href="../../../../../index.html">
  <img class="logoheader" alt="DIALS" src="../../../../../_static/dials_header.png" />
  </a>
  </div>
  

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dials.algorithms.symmetry.cosym.target</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Target function for cosym analysis.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">orderedset</span> <span class="kn">import</span> <span class="n">OrderedSet</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">import</span> <span class="nn">cctbx.sgtbx.cosets</span>
<span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">miller</span><span class="p">,</span> <span class="n">sgtbx</span>
<span class="kn">from</span> <span class="nn">cctbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>

<span class="kn">from</span> <span class="nn">dials.algorithms.scaling.scaling_library</span> <span class="kn">import</span> <span class="n">ExtendedDatasetStatistics</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_lattice_lower_upper_index</span><span class="p">(</span><span class="n">lattices</span><span class="p">,</span> <span class="n">lattice_id</span><span class="p">):</span>
    <span class="n">lower_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lattices</span><span class="p">[</span><span class="n">lattice_id</span><span class="p">])</span>
    <span class="n">upper_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">lattice_id</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lattices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">upper_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lattices</span><span class="p">[</span><span class="n">lattice_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">lattice_id</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lattices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">lower_index</span><span class="p">,</span> <span class="n">upper_index</span>


<span class="k">def</span> <span class="nf">_compute_rij_matrix_one_row_block</span><span class="p">(</span>
    <span class="n">i</span><span class="p">,</span>
    <span class="n">lattices</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">,</span>
    <span class="n">sym_ops</span><span class="p">,</span>
    <span class="n">patterson_group</span><span class="p">,</span>
    <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">min_pairs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crystal_symmetry</span><span class="p">()</span>
    <span class="n">n_lattices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lattices</span><span class="p">)</span>
    <span class="n">rij_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">NN</span> <span class="o">=</span> <span class="n">n_lattices</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sym_ops</span><span class="p">)</span>

    <span class="n">rij_row</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rij_col</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rij_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">wij</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">wij_row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wij_col</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wij_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i_lower</span><span class="p">,</span> <span class="n">i_upper</span> <span class="o">=</span> <span class="n">_lattice_lower_upper_index</span><span class="p">(</span><span class="n">lattices</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">intensities_i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">()[</span><span class="n">i_lower</span><span class="p">:</span><span class="n">i_upper</span><span class="p">]</span>
    <span class="n">sigmas_i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sigmas</span><span class="p">()[</span><span class="n">i_lower</span><span class="p">:</span><span class="n">i_upper</span><span class="p">]</span>
    <span class="n">cb_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">sgtbx</span><span class="o">.</span><span class="n">change_of_basis_op</span><span class="p">(</span><span class="n">cb_op_k</span><span class="p">)</span> <span class="k">for</span> <span class="n">cb_op_k</span> <span class="ow">in</span> <span class="n">sym_ops</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lattices</span><span class="p">):</span>
        <span class="n">j_lower</span><span class="p">,</span> <span class="n">j_upper</span> <span class="o">=</span> <span class="n">_lattice_lower_upper_index</span><span class="p">(</span><span class="n">lattices</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">intensities_j</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">()[</span><span class="n">j_lower</span><span class="p">:</span><span class="n">j_upper</span><span class="p">]</span>
        <span class="n">sigmas_j</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sigmas</span><span class="p">()[</span><span class="n">j_lower</span><span class="p">:</span><span class="n">j_upper</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">cb_op_k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cb_ops</span><span class="p">):</span>
            <span class="n">indices_i</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">cb_op_k</span><span class="o">.</span><span class="n">as_xyz</span><span class="p">()][</span><span class="n">i_lower</span><span class="p">:</span><span class="n">i_upper</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">cb_op_kk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cb_ops</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="n">kk</span><span class="p">:</span>
                    <span class="c1"># don&#39;t include correlation of dataset with itself</span>
                    <span class="k">continue</span>

                <span class="n">ik</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_lattices</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">jk</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_lattices</span> <span class="o">*</span> <span class="n">kk</span><span class="p">)</span>

                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cb_op_k</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">cb_op_kk</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">rij_cache</span><span class="p">:</span>
                    <span class="n">cc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_pairs</span> <span class="o">=</span> <span class="n">rij_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices_j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">cb_op_kk</span><span class="o">.</span><span class="n">as_xyz</span><span class="p">()][</span><span class="n">j_lower</span><span class="p">:</span><span class="n">j_upper</span><span class="p">]</span>

                    <span class="n">matches</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">match_indices</span><span class="p">(</span><span class="n">indices_i</span><span class="p">,</span> <span class="n">indices_j</span><span class="p">)</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="n">matches</span><span class="o">.</span><span class="n">pairs</span><span class="p">()</span>
                    <span class="n">isel_i</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">isel_j</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">isel_i</span> <span class="o">=</span> <span class="n">isel_i</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                        <span class="n">patterson_group</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">indices_i</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">isel_j</span> <span class="o">=</span> <span class="n">isel_j</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                        <span class="n">patterson_group</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">indices_j</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_j</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                        <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_j</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_j</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">ma_j</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">miller_set</span><span class="o">=</span><span class="n">ms</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">intensities_j</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_j</span><span class="p">),</span>
                        <span class="n">sigmas</span><span class="o">=</span><span class="n">sigmas_j</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_j</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                        <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_i</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_i</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">ma_i</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">miller_set</span><span class="o">=</span><span class="n">ms</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">intensities_i</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_i</span><span class="p">),</span>
                        <span class="n">sigmas</span><span class="o">=</span><span class="n">sigmas_i</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isel_i</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">n_pairs</span> <span class="o">=</span> <span class="n">ma_i</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">ma_i</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_pairs</span><span class="p">:</span>
                        <span class="n">n</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corr</span><span class="p">,</span> <span class="n">neff</span> <span class="o">=</span> <span class="n">ExtendedDatasetStatistics</span><span class="o">.</span><span class="n">weighted_cchalf</span><span class="p">(</span>
                            <span class="n">ma_i</span><span class="p">,</span> <span class="n">ma_j</span><span class="p">,</span> <span class="n">assume_index_matching</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">neff</span><span class="p">:</span>
                            <span class="n">cc</span> <span class="o">=</span> <span class="n">corr</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="n">neff</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">n</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="n">rij_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_pairs</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">cc</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">min_pairs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_pairs</span> <span class="o">&lt;</span> <span class="n">min_pairs</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
                    <span class="n">wij_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                    <span class="n">wij_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jk</span><span class="p">)</span>
                    <span class="n">wij_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">rij_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                <span class="n">rij_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jk</span><span class="p">)</span>
                <span class="n">rij_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">wij_data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to calculate any correlations for dataset index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">intensities_i</span><span class="p">)</span><span class="si">}</span><span class="s2"> reflections).&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Increasing min_reflections may overcome this problem.&quot;</span>
        <span class="p">)</span>
    <span class="n">rij</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">rij_data</span><span class="p">,</span> <span class="p">(</span><span class="n">rij_row</span><span class="p">,</span> <span class="n">rij_col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span> <span class="n">NN</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">wij</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">wij_data</span><span class="p">,</span> <span class="p">(</span><span class="n">wij_row</span><span class="p">,</span> <span class="n">wij_col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span> <span class="n">NN</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">rij</span><span class="p">,</span> <span class="n">wij</span>


<div class="viewcode-block" id="Target">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target">[docs]</a>
<span class="k">class</span> <span class="nc">Target</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Target function for cosym analysis.</span>

<span class="sd">    Attributes:</span>
<span class="sd">      dim (int): The number of dimensions used in the analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Target.__init__">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">intensities</span><span class="p">,</span>
        <span class="n">lattice_ids</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_pairs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">lattice_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">cc_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialise a Target object.</span>

<span class="sd">        Args:</span>
<span class="sd">          intensities (cctbx.miller.array): The intensities on which to perform</span>
<span class="sd">            cosym analysis.</span>
<span class="sd">          lattice_ids (np.ndarray): An array of equal size to</span>
<span class="sd">            `intensities` which maps each reflection to a given lattice (dataset).</span>
<span class="sd">          weights (str): Optionally include weights in the target function.</span>
<span class="sd">            Allowed values are `None`, &quot;count&quot; and &quot;standard_error&quot;. The default</span>
<span class="sd">            is to use no weights. If &quot;count&quot; is set, then weights are equal to the</span>
<span class="sd">            number of pairs of reflections used in calculating each value of the</span>
<span class="sd">            rij matrix. If &quot;standard_error&quot; is used, then weights are defined as</span>
<span class="sd">            :math:`w_{ij} = 1/s`, where :math:`s = \sqrt{(1-r_{ij}^2)/(n-2)}`.</span>
<span class="sd">            See also http://www.sjsu.edu/faculty/gerstman/StatPrimer/correlation.pdf.</span>
<span class="sd">          min_pairs (int): Only calculate the correlation coefficient between two</span>
<span class="sd">            datasets if they have more than `min_pairs` of common reflections.</span>
<span class="sd">          lattice_group (cctbx.sgtbx.space_group): Optionally set the lattice</span>
<span class="sd">            group to be used in the analysis.</span>
<span class="sd">          dimensions (int): Optionally override the number of dimensions to be used</span>
<span class="sd">            in the analysis. If not set, then the number of dimensions used is</span>
<span class="sd">            equal to the greater of 2 or the number of symmetry operations in the</span>
<span class="sd">            lattice group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">weights</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;standard_error&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_pairs</span> <span class="o">=</span> <span class="n">min_pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nproc</span> <span class="o">=</span> <span class="n">nproc</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">intensities</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">anomalous_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cb_op_to_primitive</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">change_of_basis_op_to_primitive_setting</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">change_basis</span><span class="p">(</span><span class="n">cb_op_to_primitive</span><span class="p">)</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">()</span>

        <span class="c1"># Convert to uint64 avoids crashes on Windows when later constructing</span>
        <span class="c1"># flex.size_t (https://github.com/cctbx/cctbx_project/issues/591)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">lattice_ids</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">sorted_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">size_t</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">size_t</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="n">sorted_sigmas</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sigmas</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">size_t</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_ids</span> <span class="o">=</span> <span class="n">lattice_ids</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">sorted_indices</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">sorted_data</span><span class="p">,</span> <span class="n">sigmas</span><span class="o">=</span><span class="n">sorted_sigmas</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="nb">type</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">miller_index</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="nb">type</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">()))</span>

        <span class="c1"># construct a lookup for the separate lattices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattice_ids</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattice_ids</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">([</span><span class="s2">&quot;x,y,z&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span> <span class="o">=</span> <span class="n">lattice_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">as_xyz</span><span class="p">()</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_twin_operators</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">space_group</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">sym_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span><span class="o">.</span><span class="n">expand_smx</span><span class="p">(</span><span class="n">sym_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patterson_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span><span class="o">.</span><span class="n">build_derived_patterson_group</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Lattice group: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%i</span><span class="s2"> symops)&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span><span class="o">.</span><span class="n">info</span><span class="p">()</span><span class="o">.</span><span class="n">symbol_and_number</span><span class="p">(),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Patterson group: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterson_group</span><span class="o">.</span><span class="n">info</span><span class="p">()</span><span class="o">.</span><span class="n">symbol_and_number</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cc_weights</span> <span class="o">==</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rij_wij_ccweights</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rij_wij</span><span class="p">()</span></div>


<div class="viewcode-block" id="Target.set_dimensions">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.set_dimensions">[docs]</a>
    <span class="k">def</span> <span class="nf">set_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the number of dimensions for analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">          dimensions (int): The number of dimensions to be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dimensions</span></div>


    <span class="k">def</span> <span class="nf">_generate_twin_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice_symmetry_max_delta</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
        <span class="c1"># see also mmtbx.scaling.twin_analyses.twin_laws</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cb_op_to_minimum_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">change_of_basis_op_to_minimum_cell</span><span class="p">()</span>
            <span class="n">minimum_cell_symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">crystal_symmetry</span><span class="p">()</span><span class="o">.</span><span class="n">change_basis</span><span class="p">(</span>
                <span class="n">cb_op</span><span class="o">=</span><span class="n">cb_op_to_minimum_cell</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span> <span class="o">=</span> <span class="n">sgtbx</span><span class="o">.</span><span class="n">lattice_symmetry</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                <span class="n">reduced_cell</span><span class="o">=</span><span class="n">minimum_cell_symmetry</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">(),</span>
                <span class="n">max_delta</span><span class="o">=</span><span class="n">lattice_symmetry_max_delta</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">intensity_symmetry</span> <span class="o">=</span> <span class="n">minimum_cell_symmetry</span><span class="o">.</span><span class="n">reflection_intensity_symmetry</span><span class="p">(</span>
                <span class="n">anomalous_flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">anomalous_flag</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">cb_op</span> <span class="o">=</span> <span class="n">cb_op_to_minimum_cell</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cb_op</span> <span class="o">=</span> <span class="n">sgtbx</span><span class="o">.</span><span class="n">change_of_basis_op</span><span class="p">()</span>
            <span class="n">intensity_symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reflection_intensity_symmetry</span><span class="p">()</span>

        <span class="n">operators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">cctbx</span><span class="o">.</span><span class="n">sgtbx</span><span class="o">.</span><span class="n">cosets</span><span class="o">.</span><span class="n">left_decomposition</span><span class="p">(</span>
            <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattice_group</span><span class="p">,</span>
            <span class="n">h</span><span class="o">=</span><span class="n">intensity_symmetry</span><span class="o">.</span><span class="n">space_group</span><span class="p">()</span>
            <span class="o">.</span><span class="n">build_derived_acentric_group</span><span class="p">()</span>
            <span class="o">.</span><span class="n">make_tidy</span><span class="p">(),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">partition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">r</span><span class="p">()</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">operators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cb_op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">partition</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">operators</span>

    <span class="k">def</span> <span class="nf">_compute_rij_wij_ccweights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Use flex-based methods for calculating matrices.</span>
        <span class="c1"># Pre-calculate miller indices after application of each cb_op. Only calculate</span>
        <span class="c1"># this once per cb_op instead of on-the-fly every time we need it.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">epsilons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">space_group_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">space_group</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cb_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">:</span>
            <span class="n">cb_op</span> <span class="o">=</span> <span class="n">sgtbx</span><span class="o">.</span><span class="n">change_of_basis_op</span><span class="p">(</span><span class="n">cb_op</span><span class="p">)</span>
            <span class="n">indices_reindexed</span> <span class="o">=</span> <span class="n">cb_op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
            <span class="n">miller</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">(</span><span class="n">space_group_type</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">indices_reindexed</span><span class="p">)</span>
            <span class="n">cb_op_str</span> <span class="o">=</span> <span class="n">cb_op</span><span class="o">.</span><span class="n">as_xyz</span><span class="p">()</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">cb_op_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices_reindexed</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">cb_op_str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterson_group</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">indices_reindexed</span><span class="p">)</span>

        <span class="n">rij_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">wij_matrix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="c1"># note we use weights=True to help us work out where we have calculated rij,</span>
            <span class="c1"># even if the weights phil option is None</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                    <span class="n">_compute_rij_matrix_one_row_block</span><span class="p">,</span>
                    <span class="n">i</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
                    <span class="n">indices</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_patterson_group</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">min_pairs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_pairs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                <span class="n">rij</span><span class="p">,</span> <span class="n">wij</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">rij_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rij_matrix</span> <span class="o">=</span> <span class="n">rij</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rij_matrix</span> <span class="o">+=</span> <span class="n">rij</span>
                <span class="k">if</span> <span class="n">wij</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wij_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">wij_matrix</span> <span class="o">=</span> <span class="n">wij</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wij_matrix</span> <span class="o">+=</span> <span class="n">wij</span>

        <span class="n">rij_matrix</span> <span class="o">=</span> <span class="n">rij_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">:</span>
            <span class="c1">## use the counts as weights</span>
            <span class="n">wij_matrix</span> <span class="o">=</span> <span class="n">wij_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">==</span> <span class="s2">&quot;standard_error&quot;</span><span class="p">:</span>
                <span class="c1"># N.B. using effective n due to sigma weighting, which can be below 2</span>
                <span class="c1"># but approches 1 in the limit, so rather say efective sample size</span>
                <span class="c1"># for standard error calc is n-1</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wij_matrix</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">rij_matrix</span><span class="p">[</span><span class="n">sel</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">wij_matrix</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">wij_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rij_matrix</span><span class="p">)</span>
                <span class="n">wij_matrix</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">se</span>
            <span class="c1"># rescale the weights matrix such that the sum of wij_matrix == the number of non-zero entries</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">wij_matrix</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wij_matrix</span><span class="p">)</span>
            <span class="n">wij_matrix</span> <span class="o">*=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">## No weights - i.e. equal weights in places where we can calculate an rij value,</span>
            <span class="c1">## but also making sure our diagonal elements are zero as we exclude the</span>
            <span class="c1">## self-correlation elements from rij and the cosym procedure - we need zero weights</span>
            <span class="c1">## for uncalculate correlations so they aren&#39;t taken into account in the functional</span>
            <span class="c1">## evaluation.</span>
            <span class="c1">## at this point, wij matrix contains neff values where it was possible to calculate</span>
            <span class="c1">## a pairwise correlation.</span>
            <span class="n">wij_matrix</span> <span class="o">=</span> <span class="n">wij_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wij_matrix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">wij_matrix</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">rij_matrix</span><span class="p">,</span> <span class="n">wij_matrix</span>

    <span class="k">def</span> <span class="nf">_compute_rij_wij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the rij_wij matrix.</span>

<span class="sd">        Rij is a symmetric matrix of size (n x m, n x m), where n is the number of</span>
<span class="sd">        datasets and m is the number of symmetry operations.</span>

<span class="sd">        It is composed of (m, m) blocks of size (n, n), where each block contains the</span>
<span class="sd">        correlation coefficients between cb_op_k applied to datasets 1..N with</span>
<span class="sd">        cb_op_kk applied to datasets 1.. N.</span>

<span class="sd">        If `use_cache=True`, then an optimisation is made to reflect the fact some elements</span>
<span class="sd">        of the matrix are equivalent, i.e.:</span>
<span class="sd">            CC[(a, cb_op_k), (b, cb_op_kk)] == CC[(a,), (b, cb_op_k.inverse() * cb_op_kk)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_lattices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span><span class="p">)</span>
        <span class="n">n_sym_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">)</span>

        <span class="c1"># Pre-calculate miller indices after application of each cb_op. Only calculate</span>
        <span class="c1"># this once per cb_op instead of on-the-fly every time we need it.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">epsilons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">space_group_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">space_group</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cb_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">:</span>
            <span class="n">cb_op</span> <span class="o">=</span> <span class="n">sgtbx</span><span class="o">.</span><span class="n">change_of_basis_op</span><span class="p">(</span><span class="n">cb_op</span><span class="p">)</span>
            <span class="n">indices_reindexed</span> <span class="o">=</span> <span class="n">cb_op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
            <span class="n">miller</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">(</span><span class="n">space_group_type</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">indices_reindexed</span><span class="p">)</span>
            <span class="n">cb_op_str</span> <span class="o">=</span> <span class="n">cb_op</span><span class="o">.</span><span class="n">as_xyz</span><span class="p">()</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">cb_op_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">h</span><span class="o">.</span><span class="n">iround</span><span class="p">()</span><span class="o">.</span><span class="n">as_numpy_array</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">indices_reindexed</span><span class="o">.</span><span class="n">as_vec3_double</span><span class="p">()</span><span class="o">.</span><span class="n">parts</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">cb_op_str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterson_group</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span>
                <span class="n">indices_reindexed</span>
            <span class="p">)</span><span class="o">.</span><span class="n">as_numpy_array</span><span class="p">()</span>
        <span class="n">intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">as_numpy_array</span><span class="p">()</span>

        <span class="c1"># Map indices to an array of flat 1d indices which can later be used for</span>
        <span class="c1"># matching pairs of indices</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">cb_op</span><span class="p">,</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">cb_op</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">hkl</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="c1"># Create an empty 2D array of shape (m * n, L), where m is the number of sym</span>
        <span class="c1"># ops, n is the number of lattices, and L is the number of unique miller indices</span>
        <span class="n">all_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_sym_ops</span> <span class="o">*</span> <span class="n">n_lattices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>

        <span class="c1"># Populate all_intensities with intensity values, filling absent intensities</span>
        <span class="c1"># with np.nan</span>
        <span class="n">all_intensities</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span><span class="p">,</span> <span class="n">intensities</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mil_ind</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">epsilons</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">selection</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
                <span class="c1"># map (i, j) to a column in all_intensities</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">n_sym_ops</span><span class="p">,</span> <span class="n">n_lattices</span><span class="p">))</span>
                <span class="n">epsilon_equals_one</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">valid_mil_ind</span> <span class="o">=</span> <span class="n">mil_ind</span><span class="p">[</span><span class="n">selection</span><span class="p">][</span><span class="n">epsilon_equals_one</span><span class="p">]</span>
                <span class="n">valid_intensities</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">selection</span><span class="p">][</span><span class="n">epsilon_equals_one</span><span class="p">]</span>
                <span class="n">all_intensities</span><span class="p">[</span><span class="n">column</span><span class="p">,</span> <span class="n">valid_mil_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_intensities</span>

        <span class="c1"># Ideally we would use `np.ma.corrcoef` here, but it is broken, so use</span>
        <span class="c1"># pd.DataFrame.corr() instead (see numpy/numpy#15601)</span>
        <span class="n">rij</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">all_intensities</span><span class="p">)</span>
            <span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">min_periods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_pairs</span><span class="p">)</span>
            <span class="o">.</span><span class="n">values</span>
        <span class="p">)</span>
        <span class="c1"># Set any NaN correlation coefficients to zero</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">rij</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Cosym does not make use of the on-diagonal correlation coefficients</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">rij</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">## First, populate a weights matrix of the number of pairs i.e. counts</span>
        <span class="c1">## if we are not going to use weights, this helps us select where we</span>
        <span class="c1">## calculated values, so that we can set them to constant weights</span>
        <span class="n">wij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rij</span><span class="p">)</span>
        <span class="n">right_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">wij</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each correlation coefficient, set the weight equal to the size of</span>
        <span class="c1"># the sample used to calculate that coefficient</span>
        <span class="n">pairwise_combos</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">all_intensities</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">sample_size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pairs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_pairs</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pairs</span>

        <span class="n">wij</span><span class="p">[</span><span class="n">right_up</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">pairwise_combos</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">:</span>
            <span class="c1">## the weights are currently the pairwise sample sizes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">==</span> <span class="s2">&quot;standard_error&quot;</span><span class="p">:</span>
                <span class="c1"># Set each weights as the reciprocal of the standard error on the</span>
                <span class="c1"># corresponding correlation coefficient</span>
                <span class="c1"># http://www.sjsu.edu/faculty/gerstman/StatPrimer/correlation.pdf</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">reciprocal_se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">wij</span><span class="p">[</span><span class="n">right_up</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">rij</span><span class="p">[</span><span class="n">right_up</span><span class="p">]))</span>
                    <span class="p">)</span>

                <span class="n">wij</span><span class="p">[</span><span class="n">right_up</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wij</span><span class="p">[</span><span class="n">right_up</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">reciprocal_se</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Symmetrise the wij matrix</span>
            <span class="n">wij</span> <span class="o">+=</span> <span class="n">wij</span><span class="o">.</span><span class="n">T</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">wij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]):</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n_lattices</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">-=</span> <span class="n">n_lattices</span>
                    <span class="n">n_refl</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattice_ids</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unable to calculate any correlations for dataset index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_refl</span><span class="si">}</span><span class="s2"> reflections).&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Increasing min_reflections may overcome this problem.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># rescale the weights matrix such that the sum of wij_matrix == the number of non-zero entries</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">wij</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wij</span><span class="p">)</span>
            <span class="n">wij</span> <span class="o">*=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">## we are not going to use weights, so set them to constant weights</span>
            <span class="c1">## as we still needs zeros to avoid inclusion of uncalculate values in</span>
            <span class="c1">## the functional evaluation.</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wij</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">wij</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># Symmetrise the wij matrix</span>
            <span class="n">wij</span> <span class="o">+=</span> <span class="n">wij</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">rij</span><span class="p">,</span> <span class="n">wij</span>

<div class="viewcode-block" id="Target.compute_functional">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.compute_functional">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_functional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the target function at coordinates `x`.</span>

<span class="sd">        Args:</span>
<span class="sd">          x (np.ndarray):</span>
<span class="sd">            a flattened list of the N-dimensional vectors, i.e. coordinates in</span>
<span class="sd">            the first dimension are stored first, followed by the coordinates in</span>
<span class="sd">            the second dimension, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">          f (float): The value of the target function at coordinates `x`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lattices</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sym_ops</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">elements</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">elements</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="Target.compute_functional_score_for_dimension_assessment">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.compute_functional_score_for_dimension_assessment">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_functional_score_for_dimension_assessment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">outlier_rejection</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">outlier_rejection</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">elements</span><span class="p">)</span>

        <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">))</span>
        <span class="n">inliers</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">elements</span> <span class="o">&lt;</span> <span class="n">q2</span> <span class="o">+</span> <span class="p">(</span><span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="Target.compute_gradients_fd">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.compute_gradients_fd">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradients_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the gradients at coordinates `x` using finite differences.</span>

<span class="sd">        Args:</span>
<span class="sd">          x (np.ndarray):</span>
<span class="sd">            a flattened list of the N-dimensional vectors, i.e. coordinates in</span>
<span class="sd">            the first dimension are stored first, followed by the coordinates in</span>
<span class="sd">            the second dimension, etc.</span>
<span class="sd">          eps (float):</span>
<span class="sd">            The value of epsilon to use in finite difference calculations.</span>

<span class="sd">        Returns:</span>
<span class="sd">          grad (np.ndarray):</span>
<span class="sd">          The gradients of the target function with respect to the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eps</span>  <span class="c1"># x + eps</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span>  <span class="c1"># x - eps</span>
            <span class="n">fm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eps</span>  <span class="c1"># reset to original values</span>
            <span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">-</span> <span class="n">fm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Target.compute_gradients">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.compute_gradients">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the gradients of the target function at coordinates `x`.</span>

<span class="sd">        Args:</span>
<span class="sd">          x (np.ndarray):</span>
<span class="sd">            a flattened list of the N-dimensional vectors, i.e. coordinates in</span>
<span class="sd">            the first dimension are stored first, followed by the coordinates in</span>
<span class="sd">            the second dimension, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">          Tuple[float, np.ndarray]:</span>
<span class="sd">          f: The value of the target function at coordinates `x`.</span>
<span class="sd">          grad: The gradients of the target function with respect to the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wrij_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">@</span> <span class="p">(</span><span class="n">wrij_matrix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grad</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>


<div class="viewcode-block" id="Target.curvatures">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.curvatures">[docs]</a>
    <span class="k">def</span> <span class="nf">curvatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the curvature of the target function at coordinates `x`.</span>

<span class="sd">        Args:</span>
<span class="sd">          x (np.ndarray):</span>
<span class="sd">            a flattened list of the N-dimensional vectors, i.e. coordinates in</span>
<span class="sd">            the first dimension are stored first, followed by the coordinates in</span>
<span class="sd">            the second dimension, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">          curvs (np.ndarray):</span>
<span class="sd">          The curvature of the target function with respect to the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wij_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">curvs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">@</span> <span class="n">wij</span>
        <span class="k">return</span> <span class="n">curvs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>


<div class="viewcode-block" id="Target.curvatures_fd">
<a class="viewcode-back" href="../../../../../documentation/library_reference/algorithms/dials.algorithms.symmetry.html#dials.algorithms.symmetry.cosym.target.Target.curvatures_fd">[docs]</a>
    <span class="k">def</span> <span class="nf">curvatures_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the curvatures at coordinates `x` using finite differences.</span>

<span class="sd">        Args:</span>
<span class="sd">          x (np.ndarray):</span>
<span class="sd">            a flattened list of the N-dimensional vectors, i.e. coordinates in</span>
<span class="sd">            the first dimension are stored first, followed by the coordinates in</span>
<span class="sd">            the second dimension, etc.</span>
<span class="sd">          eps (float):</span>
<span class="sd">            The value of epsilon to use in finite difference calculations.</span>

<span class="sd">        Returns:</span>
<span class="sd">          curvs (np.ndarray):</span>
<span class="sd">          The curvature of the target function with respect to the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">curvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eps</span>  <span class="c1"># x + eps</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span>  <span class="c1"># x - eps</span>
            <span class="n">fm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eps</span>  <span class="c1"># reset to original values</span>
            <span class="n">curvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fm</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">f</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">eps</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curvs</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><!--<h3>Navigation</h3>-->
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../documentation/index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../documentation/tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../howto.html">How-to</a></li>
<li class="toctree-l1"><a class="reference external" href="https://dials.github.io/kb">Knowledge Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../workshops/index.html">Workshops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../national_resource.html">US National Resource</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../projects.html">Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer container">
  <a href="https://www.diamond.ac.uk/"><img class="logofooter" alt="Diamond" src="../../../../../_static/diamond_logo.png" /></a>
  <a href="https://www.ccp4.ac.uk/"><img class="logofooter" alt="CCP4" src="../../../../../_static/CCP4-logo-plain.png" /></a>
  <a href="https://www.stfc.ac.uk/"><img class="logofooter" alt="STFC" src="https://dials.github.io/images/logos/ukri-stfc.png" /></a>
  <a href="https://www.lbl.gov/"><img class="logofooter" alt="LBL" src="https://dials.github.io/images/logos/lbl.png" /></a>
  <a href="http://smb.slac.stanford.edu/"><img class="logofooter" alt="SSRL/SMB" src="https://dials.github.io/images/logos/smbssrl.jpg" /></a>
  </div>

  <script type="text/javascript">
     $(document).ready(function() {
         $(".toggle > *").hide();
         $(".toggle .header").show();
         $(".toggle .header").click(function() {
             $(this).parent().children().not(".header").toggle(400);
             $(this).parent().children(".header").toggleClass("open");
         })
     });
  </script>
  
    <div class="footer">
      &#169;2025, Diamond Light Source, Lawrence Berkeley National Laboratory and STFC.
      
    </div>

    

    

  </body>
</html>