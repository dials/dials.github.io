

<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>dials.index &#8212; DIALS  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="dials.refine_bravais_settings" href="dials_refine_bravais_settings.html" />
    <link rel="prev" title="dials.find_spots" href="dials_find_spots.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="dials-index">
<h1>dials.index<a class="headerlink" href="#dials-index" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This program attempts to perform autoindexing on strong spots output by the
program dials.find_spots. The program is called with a “imported.expt” file
(as generated by dials.import) and a “strong.refl” file (as generated by
dials.find_spots). If one or more lattices are identified given the input
list of strong spots, then the crystal orientation and experimental geometry
are refined to minimise the differences between the observed and predicted
spot centroids. The program will output an “indexed.expt” file which
is similar to the input “imported.expt” file, but with the addition of the
crystal model(s), and an “indexed.refl” file which is similar to the input
“strong.refl” file, but with the addition of miller indices and predicted
spot centroids.</p>
<p>dials.index provides both one-dimensional and three-dimensional fast Fourier
transform (FFT) based methods. These can be chosen by setting the parameters
indexing.method=fft1d or indexing.method=fft3d. By default the program searches
for a primitive lattice, and then proceeds with refinement in space group P1.
If the unit_cell and space_group parameters are set, then the program will
only accept solutions which are consistent with these parameters. Space group
constraints will be enforced in refinement as appropriate.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">imported</span><span class="o">.</span><span class="n">expt</span> <span class="n">strong</span><span class="o">.</span><span class="n">refl</span>

<span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">imported</span><span class="o">.</span><span class="n">expt</span> <span class="n">strong</span><span class="o">.</span><span class="n">refl</span> <span class="n">unit_cell</span><span class="o">=</span><span class="mi">37</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span> <span class="n">space_group</span><span class="o">=</span><span class="n">P43212</span>

<span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">imported</span><span class="o">.</span><span class="n">expt</span> <span class="n">strong</span><span class="o">.</span><span class="n">refl</span> <span class="n">indexing</span><span class="o">.</span><span class="n">method</span><span class="o">=</span><span class="n">fft1d</span>
</pre></div>
</div>
</section>
<section id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Link to this heading">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indexing</span> <span class="p">{</span>
  <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">known_symmetry</span> <span class="p">{</span>
    <span class="n">space_group</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unit_cell</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="p">}</span>
  <span class="n">index_assignment</span> <span class="p">{</span>
    <span class="n">simple</span> <span class="p">{</span>
      <span class="n">hkl_tolerance</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">check_misindexing</span> <span class="p">{</span>
    <span class="n">grid_search_scope</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="n">refinement_protocol</span> <span class="p">{</span>
    <span class="n">n_macro_cycles</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">d_min_step</span> <span class="o">=</span> <span class="n">Auto</span>
    <span class="n">d_min_start</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">d_min_final</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="p">}</span>
  <span class="n">stills</span> <span class="p">{</span>
    <span class="n">ewald_proximity_resolution_cutoff</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">refine_all_candidates</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">rmsd_min_px</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ewald_proximal_volume_max</span> <span class="o">=</span> <span class="mf">0.0025</span>
    <span class="n">isoforms</span> <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">lookup_symbol</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">rmsd_target_mm</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">beam_restraint</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">}</span>
    <span class="n">set_domain_size_ang_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">set_mosaic_half_deg_value</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">indexing</span> <span class="p">{</span>
  <span class="n">method</span> <span class="o">=</span> <span class="n">fft1d</span> <span class="o">*</span><span class="n">fft3d</span> <span class="n">real_space_grid_search</span> <span class="n">ffbidx</span> <span class="n">low_res_spot_match</span> \
           <span class="n">pink_indexer</span>
  <span class="n">image_range</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="n">joint_indexing</span> <span class="o">=</span> <span class="n">Auto</span>
<span class="p">}</span>
<span class="n">refinement</span> <span class="p">{</span>
  <span class="n">parameterisation</span> <span class="p">{</span>
    <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">beam</span> <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="o">*</span><span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="o">*</span><span class="n">wavelength</span>
    <span class="p">}</span>
    <span class="n">crystal</span> <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">cell</span> <span class="n">orientation</span>
    <span class="p">}</span>
    <span class="n">detector</span> <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">position</span> <span class="n">orientation</span> <span class="n">distance</span>
    <span class="p">}</span>
    <span class="n">goniometer</span> <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">reflections</span> <span class="p">{</span>
    <span class="n">outlier</span> <span class="p">{</span>
      <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="o">*</span><span class="n">auto</span> <span class="n">mcd</span> <span class="n">tukey</span> <span class="n">sauter_poon</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">experiments</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">expt</span>
  <span class="n">reflections</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">refl</span>
  <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">log</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Link to this heading">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indexing</span> <span class="p">{</span>
  <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of processes to use.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">mm_search_scope</span> <span class="o">=</span> <span class="mf">4.0</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Global radius of origin offset search.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">wide_search_binning</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Modify the coarseness of the wide grid search for the beam&quot;</span>
            <span class="s2">&quot;centre.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum unit cell volume (in Angstrom^3).&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">min_cell</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum length of candidate unit cell basis vectors (in&quot;</span>
            <span class="s2">&quot;Angstrom).&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">max_cell</span> <span class="o">=</span> <span class="n">Auto</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum length of candidate unit cell basis vectors (in&quot;</span>
            <span class="s2">&quot;Angstrom).&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">max_cell_estimation</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">filter_ice</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filter out reflections at typical ice ring resolutions before&quot;</span>
              <span class="s2">&quot;max_cell estimation.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">filter_overlaps</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filter out reflections with overlapping bounding boxes before&quot;</span>
              <span class="s2">&quot;max_cell estimation.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">overlaps_border</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Optionally add a border around the bounding boxes before&quot;</span>
              <span class="s2">&quot;finding overlaps.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">multiplier</span> <span class="o">=</span> <span class="mf">1.3</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Multiply the estimated maximum basis vector length by this&quot;</span>
              <span class="s2">&quot;value.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="mi">45</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Step size, in degrees, of the blocks used to perform the&quot;</span>
              <span class="s2">&quot;max_cell  estimation.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">nearest_neighbor_percentile</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Percentile of NN histogram to use for max cell determination.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">histogram_binning</span> <span class="o">=</span> <span class="n">linear</span> <span class="o">*</span><span class="n">log</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose between linear or logarithmic bins for nearest neighbour&quot;</span>
              <span class="s2">&quot;histogram analysis.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">nn_per_bin</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target number of nearest neighbours per histogram bin.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_height_fraction</span> <span class="o">=</span> <span class="mf">0.25</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">}</span>
  <span class="n">sigma_phi_deg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Override the phi sigmas for refinement. Mainly intended for&quot;</span>
            <span class="s2">&quot;single-shot rotation images where the phi sigma is almost&quot;</span>
            <span class="s2">&quot;certainly incorrect.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">known_symmetry</span> <span class="p">{</span>
    <span class="n">space_group</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target space group for indexing.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">space_group</span>
    <span class="n">unit_cell</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target unit cell for indexing.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">unit_cell</span>
    <span class="n">relative_length_tolerance</span> <span class="o">=</span> <span class="mf">0.1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Relative tolerance for unit cell lengths in unit cell&quot;</span>
              <span class="s2">&quot;comparison.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">absolute_angle_tolerance</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Angular tolerance (in degrees) in unit cell comparison.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">max_delta</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum allowed Le Page delta used in searching for basis&quot;</span>
              <span class="s2">&quot;vector combinations that are consistent with the given&quot;</span>
              <span class="s2">&quot;symmetry.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">index_assignment</span> <span class="p">{</span>
    <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">simple</span> <span class="n">local</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose between simple &#39;global&#39; index assignment and xds-style &quot;</span>
              <span class="s2">&quot;&#39;local&#39; index assignment.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">simple</span> <span class="p">{</span>
      <span class="n">hkl_tolerance</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum allowable deviation from integer-ness for assigning &quot;</span>
                <span class="s2">&quot;a miller index to a reciprocal lattice vector.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">local</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_ERROR=&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">delta</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_MAGNITUDE=&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">l_min</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_QUALITY=&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">nearest_neighbours</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">check_misindexing</span> <span class="p">{</span>
    <span class="n">grid_search_scope</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search scope for testing misindexing on h, k, l.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">combine_scans</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">refinement_protocol</span> <span class="p">{</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="o">*</span><span class="n">refine_shells</span> <span class="n">repredict_only</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;refine_shells: if using sequences indexer, refine in increasing&quot;</span>
              <span class="s2">&quot;resolution cutoffs after indexing, if using stills indexer,&quot;</span>
              <span class="s2">&quot;refine all data up to d_min_start resolution once only.&quot;</span>
              <span class="s2">&quot;repredict_only: do not refine after indexing, just update spot&quot;</span>
              <span class="s2">&quot;predictions. None: do not refine and do not update spot&quot;</span>
              <span class="s2">&quot;predictions.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n_macro_cycles</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of macro cycles of refinement, reindexing all&quot;</span>
              <span class="s2">&quot;reflections using updated geometry at the beginning of each&quot;</span>
              <span class="s2">&quot;cycle. Does not apply to stills.indexer=stills.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d_min_step</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reduction per step in d_min for reflections to include in&quot;</span>
              <span class="s2">&quot;refinement. Does not apply to stills.indexer=stills.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d_min_start</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For sequences/stills indexer, the lower limit of d-spacing of&quot;</span>
              <span class="s2">&quot;reflections used in the first/the only round of refinement.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d_min_final</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Do not ever include reflections below this value in refinement.&quot;</span>
              <span class="s2">&quot;Does not apply to stills.indexer=stills.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">disable_unit_cell_volume_sanity_check</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Disable sanity check on unrealistic increases in unit cell&quot;</span>
              <span class="s2">&quot;volume during refinement. Does not apply to&quot;</span>
              <span class="s2">&quot;stills.indexer=stills.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">multiple_lattice_search</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">recycle_unindexed_reflections_cutoff</span> <span class="o">=</span> <span class="mf">0.1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Attempt another cycle of indexing on the unindexed reflections &quot;</span>
              <span class="s2">&quot;if more than the fraction of input reflections are unindexed.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">minimum_angular_separation</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum angular separation (in degrees) between two&quot;</span>
              <span class="s2">&quot;lattices.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_lattices</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cluster_analysis</span> <span class="p">{</span>
      <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">dbscan</span> <span class="n">hcluster</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">hcluster</span> <span class="p">{</span>
        <span class="n">linkage</span> <span class="p">{</span>
          <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">ward</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
          <span class="n">metric</span> <span class="o">=</span> <span class="o">*</span><span class="n">euclidean</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="p">}</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="mi">15</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cutoff_criterion</span> <span class="o">=</span> <span class="o">*</span><span class="n">distance</span> <span class="n">inconsistent</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="p">}</span>
      <span class="n">dbscan</span> <span class="p">{</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.05</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">min_samples</span> <span class="o">=</span> <span class="mi">30</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">min_cluster_size</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">intersection_union_ratio_cutoff</span> <span class="o">=</span> <span class="mf">0.4</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">stills</span> <span class="p">{</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="o">*</span><span class="n">Auto</span> <span class="n">stills</span> <span class="n">sequences</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Use the stills or sequences indexer. Auto: choose based on the&quot;</span>
              <span class="s2">&quot;input imagesets (stills or sequences).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ewald_proximity_resolution_cutoff</span> <span class="o">=</span> <span class="mf">2.0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;the acceptable volume of reciprocal space for spot prediction&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">refine_all_candidates</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If False, no attempt is made to refine the model from initial&quot;</span>
              <span class="s2">&quot;basis vector selection. The indexing solution with the best&quot;</span>
              <span class="s2">&quot;RMSD is chosen.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">candidate_outlier_rejection</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If True, while refining candidate basis solutions, also apply&quot;</span>
              <span class="s2">&quot;Sauter/ Poon (2010) outlier rejection&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">refine_candidates_with_known_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If False, when choosing the best set of candidate basis&quot;</span>
              <span class="s2">&quot;solutions, refine the candidates in the P1 setting. If True,&quot;</span>
              <span class="s2">&quot;after indexing in P1, convert the candidates to the known&quot;</span>
              <span class="s2">&quot;symmetry and apply the corresponding change of basis to the&quot;</span>
              <span class="s2">&quot;indexed reflections.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">rmsd_min_px</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum acceptable RMSD for choosing candidate basis solutions&quot;</span>
              <span class="s2">&quot;(in pixels)&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ewald_proximal_volume_max</span> <span class="o">=</span> <span class="mf">0.0025</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum acceptable ewald proximal volume when choosing&quot;</span>
              <span class="s2">&quot;candidate basis solutions&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">isoforms</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Constrain the unit cell to specific values during refinement&quot;</span>
              <span class="s2">&quot;after initial indexing.&quot;</span>
      <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">unit_cell</span>
      <span class="n">lookup_symbol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The sgtbx lookup symbol of the reflections pointgroup&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="n">rmsd_target_mm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum acceptable DIALS positional rmsd, in mm&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">beam_restraint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;to assure that no images are accepted where the lattice is&quot;</span>
                <span class="s2">&quot;misindexed by a unit shift.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">set_domain_size_ang_value</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If specified, will set the domain size ang value and override&quot;</span>
              <span class="s2">&quot;the value determined from nave refinement&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">set_mosaic_half_deg_value</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If specified, will set the mosaic half degree value and&quot;</span>
              <span class="s2">&quot;override the value determined from nave refinement&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">indexing</span> <span class="p">{</span>
  <span class="n">basis_vector_combinations</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">max_combinations</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of basis vector combinations to test for&quot;</span>
              <span class="s2">&quot;agreement with input symmetry.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_refine</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of putative crystal models to test. Default for&quot;</span>
              <span class="s2">&quot;rotation sequences: 50, for still images: 5&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sys_absent_threshold</span> <span class="o">=</span> <span class="mf">0.9</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">solution_scorer</span> <span class="o">=</span> <span class="nb">filter</span> <span class="o">*</span><span class="n">weighted</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nb">filter</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">check_doubled_cell</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">likelihood_cutoff</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">volume_cutoff</span> <span class="o">=</span> <span class="mf">1.25</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">n_indexed_cutoff</span> <span class="o">=</span> <span class="mf">0.9</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">weighted</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">volume_weight</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">n_indexed_weight</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">rmsd_weight</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">method</span> <span class="o">=</span> <span class="n">fft1d</span> <span class="o">*</span><span class="n">fft3d</span> <span class="n">real_space_grid_search</span> <span class="n">ffbidx</span> <span class="n">low_res_spot_match</span> \
           <span class="n">pink_indexer</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
  <span class="n">optimise_initial_basis_vectors</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">fft1d</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search for the basis vectors of the direct lattice by performing&quot;</span>
            <span class="s2">&quot;a series of 1D FFTs along various directions in reciprocal space.&quot;</span>
            <span class="s2">&quot;This has a lower memory requirement than a single 3D FFT (the&quot;</span>
            <span class="s2">&quot;fft3d method). This method may also be more appropriate than a 3D&quot;</span>
            <span class="s2">&quot;FFT if the reflections are from narrow wedges of rotation data or&quot;</span>
            <span class="s2">&quot;from stills data.&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">characteristic_grid</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Sampling frequency in radians. See Steller 1997. If None,&quot;</span>
              <span class="s2">&quot;determine a grid sampling automatically using the input&quot;</span>
              <span class="s2">&quot;reflections, using at most 0.029 radians.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">fft3d</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search for the basis vectors of the direct lattice by performing&quot;</span>
            <span class="s2">&quot;a 3D FFT in reciprocal space of the density of found spots. Since&quot;</span>
            <span class="s2">&quot;this can be quite memory-intensive, the data used for indexing&quot;</span>
            <span class="s2">&quot;may automatically be constrained to just the lower resolution&quot;</span>
            <span class="s2">&quot;spots.&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">b_iso</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="mi">15</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">peak_search</span> <span class="o">=</span> <span class="o">*</span><span class="n">flood_fill</span> <span class="n">clean</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">peak_volume_cutoff</span> <span class="o">=</span> <span class="mf">0.15</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reciprocal_space_grid</span> <span class="p">{</span>
      <span class="n">n_points</span> <span class="o">=</span> <span class="mi">256</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">d_min</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The high resolution limit in Angstrom for spots to include in&quot;</span>
                <span class="s2">&quot; the initial indexing.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">real_space_grid_search</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Index the found spots by testing a known unit cell in various&quot;</span>
            <span class="s2">&quot;orientations until the best match is found. This strategy is&quot;</span>
            <span class="s2">&quot;often useful for difficult cases of narrow-wedge rotation data or&quot;</span>
            <span class="s2">&quot;stills data, especially where there is diffraction from multiple&quot;</span>
            <span class="s2">&quot;crystals.&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">characteristic_grid</span> <span class="o">=</span> <span class="mf">0.02</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_vectors</span> <span class="o">=</span> <span class="mi">30</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of unique vectors to find in the grid&quot;</span>
              <span class="s2">&quot;search.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">ffbidx</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy for very fast indexing using Cuda&quot;</span>
            <span class="s2">&quot;acceleration&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">max_output_cells</span> <span class="o">=</span> <span class="mi">32</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of output cells&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_spots</span> <span class="o">=</span> <span class="mi">300</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reciprocal spots taken into account&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">num_candidate_vectors</span> <span class="o">=</span> <span class="mi">32</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of candidate cell vectors&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">redundant_computations</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Calculate candidates for all three cell vectors&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">dist1</span> <span class="o">=</span> <span class="mf">0.3</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reciprocal spots within this threshold contribute to the score&quot;</span>
              <span class="s2">&quot;for vector sampling&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">dist3</span> <span class="o">=</span> <span class="mf">0.15</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reciprocal spots within this threshold contribute to the score&quot;</span>
              <span class="s2">&quot;for cell sampling&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">num_halfsphere_points</span> <span class="o">=</span> <span class="mi">32768</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of sampling points on the half sphere&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_dist</span> <span class="o">=</span> <span class="mf">0.00075</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum final distance between measured and calculated&quot;</span>
              <span class="s2">&quot;reciprocal spot&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">min_spots</span> <span class="o">=</span> <span class="mi">8</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum number of reciprocal spots within distance max_dist&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">ifssr</span> <span class="n">ifss</span> <span class="n">ifse</span> <span class="n">raw</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Refinement method (consult algorithm description)&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">triml</span> <span class="o">=</span> <span class="mf">0.001</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;lower trimming value for intermediate score calculations&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">trimh</span> <span class="o">=</span> <span class="mf">0.3</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;higher trimming value for intermediate score calculations&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;log2 curve position for intermediate score calculations, lower&quot;</span>
              <span class="s2">&quot;values will me more selective in choosing close spots&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">simple_data_filename</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Optional filename for the output of a simple data file for&quot;</span>
              <span class="s2">&quot;debugging&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">}</span>
  <span class="n">low_res_spot_match</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy that matches low resolution spots to&quot;</span>
            <span class="s2">&quot;candidate indices based on a known unit cell and space group.&quot;</span>
            <span class="s2">&quot;Designed primarily for electron diffraction still images.&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">candidate_spots</span> <span class="p">{</span>
      <span class="n">limit_resolution_by</span> <span class="o">=</span> <span class="o">*</span><span class="n">n_spots</span> <span class="n">d_min</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">d_min</span> <span class="o">=</span> <span class="mf">15.0</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">n_spots</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">d_star_tolerance</span> <span class="o">=</span> <span class="mf">4.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of sigmas from the centroid position for which to &quot;</span>
                <span class="s2">&quot;calculate d* bands&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">use_P1_indices_as_seeds</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">search_depth</span> <span class="o">=</span> <span class="o">*</span><span class="n">triplets</span> <span class="n">quads</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">bootstrap_crystal</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">max_pairs</span> <span class="o">=</span> <span class="mi">200</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_triplets</span> <span class="o">=</span> <span class="mi">600</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_quads</span> <span class="o">=</span> <span class="mi">600</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">pink_indexer</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy that matches low resolution spots to&quot;</span>
            <span class="s2">&quot;candidate indices based on a known unit cell and space group. It&quot;</span>
            <span class="s2">&quot;supports mono and polychromatic beams.&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">max_refls</span> <span class="o">=</span> <span class="mi">50</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reflections to consider indexing&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The peak wavelength&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">percent_bandwidth</span> <span class="o">=</span> <span class="mf">1.</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The percent bandwidth used to calculate the wavelength range&quot;</span>
              <span class="s2">&quot;for indexing. The wavelength range is defined (wavelength -&quot;</span>
              <span class="s2">&quot;wavelength*percent_bandwidth/200, wavelength +&quot;</span>
              <span class="s2">&quot;wavelength*percent_bandwidth/200). This parameter also reflects&quot;</span>
              <span class="s2">&quot;the uncertainty of the supplied cell constants with larger&quot;</span>
              <span class="s2">&quot;values appropriate for less certain unit cells.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rotogram_grid_points</span> <span class="o">=</span> <span class="mi">180</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of points at which to evaluate the angle search for each&quot;</span>
              <span class="s2">&quot;rlp-observation pair&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">voxel_grid_points</span> <span class="o">=</span> <span class="mi">150</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Controls the number of voxels onto which the rotograms are&quot;</span>
              <span class="s2">&quot;discretized&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">min_lattices</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum number of candidate lattices to generate.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">image_range</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Range in images to slice a sequence. The number of arguments must&quot;</span>
            <span class="s2">&quot;be a factor of two. Each pair of arguments gives a range that&quot;</span>
            <span class="s2">&quot;follows C conventions (e.g. j0 &lt;= j &lt; j1) when slicing the&quot;</span>
            <span class="s2">&quot;reflections by observed centroid.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">joint_indexing</span> <span class="o">=</span> <span class="n">Auto</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
<span class="p">}</span>
<span class="n">refinement</span>
  <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinement&quot;</span>
<span class="p">{</span>
  <span class="n">mp</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">{</span>
    <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of processes to use. Not all choices of refinement&quot;</span>
              <span class="s2">&quot;engine support nproc &gt; 1. Where multiprocessing is possible, it&quot;</span>
              <span class="s2">&quot;is helpful only in certain circumstances, so this is not&quot;</span>
              <span class="s2">&quot;recommended for typical use.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">parameterisation</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to control the parameterisation of experimental models&quot;</span>
  <span class="p">{</span>
    <span class="n">auto_reduction</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;determine behaviour when there are too few reflections to&quot;</span>
              <span class="s2">&quot;reasonably produce a full parameterisation of the experiment&quot;</span>
              <span class="s2">&quot;list&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">min_nref_per_parameter</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;the smallest number of reflections per parameter for a model&quot;</span>
                <span class="s2">&quot;parameterisation below which the parameterisation will not be&quot;</span>
                <span class="s2">&quot;made in full, but the action described below will be&quot;</span>
                <span class="s2">&quot;triggered.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="n">fail</span> <span class="n">fix</span> <span class="n">remove</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;action to take if there are too few reflections across the&quot;</span>
                <span class="s2">&quot;experiments related to a particular model parameterisation.&quot;</span>
                <span class="s2">&quot;If fail, an exception will be raised and refinement will not&quot;</span>
                <span class="s2">&quot;proceed. If fix, refinement will continue but with the&quot;</span>
                <span class="s2">&quot;parameters relating to that model remaining fixed at their&quot;</span>
                <span class="s2">&quot;initial values. If remove, parameters relating to that model&quot;</span>
                <span class="s2">&quot;will be fixed, and in addition all reflections related to&quot;</span>
                <span class="s2">&quot;that parameterisation will be removed. This will therefore&quot;</span>
                <span class="s2">&quot;remove these reflections from other parameterisations of the&quot;</span>
                <span class="s2">&quot;global model too. For example, if a crystal model could not&quot;</span>
                <span class="s2">&quot;be parameterised it will be excised completely and not&quot;</span>
                <span class="s2">&quot;contribute to the joint refinement of the detector and beam.&quot;</span>
                <span class="s2">&quot;In the fix mode, reflections emanating from that crystal will&quot;</span>
                <span class="s2">&quot;still form residuals and will contribute to detector and beam&quot;</span>
                <span class="s2">&quot;refinement.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="p">}</span>
    <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Allow models that are not forced to be static to vary during&quot;</span>
              <span class="s2">&quot;the scan, Auto will run one macrocycle with static then scan&quot;</span>
              <span class="s2">&quot;varying refinement for the crystal&quot;</span>
      <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Scan-varying refinement&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Overall default value of the width of scan between checkpoints&quot;</span>
              <span class="s2">&quot;in degrees for scan-varying refinement. If set to None, each&quot;</span>
              <span class="s2">&quot;model will use its own specified value.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">compose_model_per</span> <span class="o">=</span> <span class="n">image</span> <span class="o">*</span><span class="n">block</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying parameterisations, compose a new model either&quot;</span>
              <span class="s2">&quot;every image or within blocks of a width specified in the&quot;</span>
              <span class="s2">&quot;reflections parameters. When this block width is larger than&quot;</span>
              <span class="s2">&quot;the image width the result is faster, with a trade-off in&quot;</span>
              <span class="s2">&quot;accuracy&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">block_width</span> <span class="o">=</span> <span class="mf">1.0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of a reflection &#39;block&#39; (in degrees) determining how&quot;</span>
              <span class="s2">&quot;fine- grained the model used for scan-varying prediction during&quot;</span>
              <span class="s2">&quot;refinement is. Currently only has any effect if the crystal&quot;</span>
              <span class="s2">&quot;parameterisation is set to use compose_model_per=block&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If scan-varying refinement is done, and if the estimated&quot;</span>
              <span class="s2">&quot;covariance of the model states have been calculated by the&quot;</span>
              <span class="s2">&quot;minimiser, choose whether to return this to the models or not.&quot;</span>
              <span class="s2">&quot;The default is not to, in order to keep the file size of the&quot;</span>
              <span class="s2">&quot;serialized model small. At the moment, this only has an effect&quot;</span>
              <span class="s2">&quot;for crystal unit cell (B matrix) errors.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">trim_scan_to_observations</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying refinement, trim scan objects to the range of&quot;</span>
              <span class="s2">&quot;observed reflections. This avoids failures in refinement for&quot;</span>
              <span class="s2">&quot;cases where the extremes of scans contain no data, such as when&quot;</span>
              <span class="s2">&quot;the crystal moves out of the beam.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">debug_centroid_analysis</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set True to write out a file containing the reflections used&quot;</span>
              <span class="s2">&quot;for centroid analysis for automatic setting of the &quot;</span>
              <span class="s2">&quot;scan-varying interval width. This can then be analysed with&quot;</span>
              <span class="s2">&quot;dev.dials.plot_centroid_analysis (requires dials_scratch&quot;</span>
              <span class="s2">&quot;repository).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">beam</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;beam parameters&quot;</span>
    <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="o">*</span><span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="o">*</span><span class="n">wavelength</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix beam parameters. By default, in_spindle_plane&quot;</span>
                <span class="s2">&quot;is selected, and one of the two parameters is fixed. If a&quot;</span>
                <span class="s2">&quot;goniometer is present this leads to the beam orientation&quot;</span>
                <span class="s2">&quot;being restricted to a direction in the initial spindle-beam&quot;</span>
                <span class="s2">&quot;plane. Wavelength is also fixed by default, to allow&quot;</span>
                <span class="s2">&quot;refinement of the unit cell volume.&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix beam parameters&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                <span class="s2">&quot;partial names to match&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">constraints</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
        <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="p">{</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up which&quot;</span>
                  <span class="s2">&quot;parameterisations to apply the constraint to. If an&quot;</span>
                  <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                  <span class="s2">&quot;then the index of any one of those experiments suffices to&quot;</span>
                  <span class="s2">&quot;identify that parameterisation. If None (the default) then&quot;</span>
                  <span class="s2">&quot;constraints will be applied to all parameterisations of&quot;</span>
                  <span class="s2">&quot;this type.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                  <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                  <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                  <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="p">}</span>
      <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the beam when doing&quot;</span>
                <span class="s2">&quot;scan-varying refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">smoother</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set to&quot;</span>
                  <span class="s2">&quot;Auto.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                  <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                  <span class="s2">&quot;interval_width_degrees&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">crystal</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;crystal parameters&quot;</span>
    <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">cell</span> <span class="n">orientation</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">unit_cell</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">restraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Least squares unit cell restraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">tie_to_target</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="p">{</span>
            <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target unit cell parameters for the restraint for this&quot;</span>
                      <span class="s2">&quot;parameterisation&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell target values are associated with sigmas&quot;</span>
                      <span class="s2">&quot;which are used to determine the weight of each&quot;</span>
                      <span class="s2">&quot;restraint. A sigma of zero will remove the restraint at&quot;</span>
                      <span class="s2">&quot;that position. If symmetry constrains two cell&quot;</span>
                      <span class="s2">&quot;dimensions to be equal then only the smaller of the two&quot;</span>
                      <span class="s2">&quot;sigmas will be kept&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which parameterisations to apply these restraints to.&quot;</span>
                      <span class="s2">&quot;If an identified parameterisation affects multiple&quot;</span>
                      <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                      <span class="s2">&quot;experiments suffices to restrain that parameterisation.&quot;</span>
                      <span class="s2">&quot;If None (the default) then the restraints will be&quot;</span>
                      <span class="s2">&quot;applied to all experiments.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">}</span>
          <span class="n">tie_to_group</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="p">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="n">mean</span> <span class="n">low_memory_mean</span> <span class="n">median</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Function to tie group parameter values to&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
            <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell parameters are associated with sigmas&quot;</span>
                      <span class="s2">&quot;which are used to determine the weight of each&quot;</span>
                      <span class="s2">&quot;restraint. A sigma of zero will remove the restraint at&quot;</span>
                      <span class="s2">&quot;that position.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which  parameterisations to apply these restraints to.&quot;</span>
                      <span class="s2">&quot;For every parameterisation that requires a restraint at&quot;</span>
                      <span class="s2">&quot;least one experiment index must be supplied. If None&quot;</span>
                      <span class="s2">&quot;(the default) the restraints will be applied to all&quot;</span>
                      <span class="s2">&quot;experiments.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal unit cell&quot;</span>
                  <span class="s2">&quot;when doing scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">orientation</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal orientation&quot;</span>
                  <span class="s2">&quot;when doing scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">detector</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;detector parameters&quot;</span>
    <span class="p">{</span>
      <span class="n">panels</span> <span class="o">=</span> <span class="o">*</span><span class="n">automatic</span> <span class="n">single</span> <span class="n">multiple</span> <span class="n">hierarchical</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select appropriate detector parameterisation. Both the single&quot;</span>
                <span class="s2">&quot;and multiple panel detector options treat the whole detector&quot;</span>
                <span class="s2">&quot;as a rigid body. The hierarchical parameterisation treats&quot;</span>
                <span class="s2">&quot;groups of panels as separate rigid bodies.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">hierarchy_level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Level of the detector hierarchy (starting from the root at 0)&quot;</span>
                <span class="s2">&quot;at which to determine panel groups to parameterise&quot;</span>
                <span class="s2">&quot;independently&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">position</span> <span class="n">orientation</span> <span class="n">distance</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters. The translational parameters&quot;</span>
                <span class="s2">&quot;(position) may be set separately to the orientation.&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                <span class="s2">&quot;partial names to match&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">constraints</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
        <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="p">{</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up which&quot;</span>
                  <span class="s2">&quot;parameterisations to apply the constraint to. If an&quot;</span>
                  <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                  <span class="s2">&quot;then the index of any one of those experiments suffices to&quot;</span>
                  <span class="s2">&quot;identify that parameterisation. If None (the default) then&quot;</span>
                  <span class="s2">&quot;constraints will be applied to all parameterisations of&quot;</span>
                  <span class="s2">&quot;this type.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                  <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                  <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                  <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="p">}</span>
      <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the detector when doing&quot;</span>
                <span class="s2">&quot;scan-varying refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">smoother</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set to&quot;</span>
                  <span class="s2">&quot;Auto.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                  <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                  <span class="s2">&quot;interval_width_degrees&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">goniometer</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;goniometer setting matrix parameters&quot;</span>
    <span class="p">{</span>
      <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix goniometer parameters. By default, fix all.&quot;</span>
                <span class="s2">&quot;Alternatively the setting matrix can be constrained to allow&quot;</span>
                <span class="s2">&quot;rotation only within the spindle-beam plane or to allow&quot;</span>
                <span class="s2">&quot;rotation only around an axis that lies in that plane. Set to&quot;</span>
                <span class="s2">&quot;None to refine the in two orthogonal directions.&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix goniometer parameters&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                <span class="s2">&quot;partial names to match&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">constraints</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
        <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="p">{</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up which&quot;</span>
                  <span class="s2">&quot;parameterisations to apply the constraint to. If an&quot;</span>
                  <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                  <span class="s2">&quot;then the index of any one of those experiments suffices to&quot;</span>
                  <span class="s2">&quot;identify that parameterisation. If None (the default) then&quot;</span>
                  <span class="s2">&quot;constraints will be applied to all parameterisations of&quot;</span>
                  <span class="s2">&quot;this type.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                  <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                  <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                  <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="p">}</span>
      <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the goniometer when doing&quot;</span>
                <span class="s2">&quot;scan-varying refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">smoother</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set to&quot;</span>
                  <span class="s2">&quot;Auto.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                  <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                  <span class="s2">&quot;interval_width_degrees&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sparse</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Calculate gradients using sparse data structures.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">treat_single_image_as_still</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to True to treat a single image scan with a non zero&quot;</span>
              <span class="s2">&quot;oscillation width as a still&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">spherical_relp_model</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For stills refinement, set true to use the spherical relp model&quot;</span>
              <span class="s2">&quot;for prediction and gradients.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">refinery</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinery&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">SimpleLBFGS</span> <span class="n">LBFGScurvs</span> <span class="n">GaussNewton</span> <span class="o">*</span><span class="n">LevMar</span> <span class="n">SparseLevMar</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimisation engine to use&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of iterations in refinement before termination.&quot;</span>
              <span class="s2">&quot;None implies the engine supplies its own default.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">log</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filename for an optional log that a minimisation engine may use&quot;</span>
              <span class="s2">&quot;to write additional information&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
    <span class="n">journal</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Extra items to track in the refinement history&quot;</span>
    <span class="p">{</span>
      <span class="n">track_step</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter shifts history in the refinement journal, if&quot;</span>
                <span class="s2">&quot;the engine supports it.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_gradient</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter gradients history in the refinement journal,&quot;</span>
                <span class="s2">&quot;if the engine supports it.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_parameter_correlation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record correlation matrix between columns of the Jacobian for&quot;</span>
                <span class="s2">&quot;each step of refinement.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_jacobian_structure</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record numbers of explicit and structural zeroes in each&quot;</span>
                <span class="s2">&quot;column of the Jacobian at each step of refinement.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_condition_number</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record condition number of the Jacobian for each step of &quot;</span>
                <span class="s2">&quot;refinement.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_normal_matrix</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record the full normal matrix at each step of refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">track_out_of_sample_rmsd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record RMSDs calculated using the refined experiments with&quot;</span>
                <span class="s2">&quot;reflections not used in refinement at each step. Only valid&quot;</span>
                <span class="s2">&quot;if a subset of input reflections was taken for refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">target</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the target function&quot;</span>
    <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="o">*</span><span class="n">fraction_of_bin_size</span> <span class="n">absolute</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Method to choose rmsd cutoffs. This is currently either as a&quot;</span>
              <span class="s2">&quot;fraction of the discrete units of the spot positional data,&quot;</span>
              <span class="s2">&quot;i.e. (pixel width, pixel height, image thickness in phi), or a&quot;</span>
              <span class="s2">&quot;tuple of absolute values to use as the cutoffs&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">bin_size_fraction</span> <span class="o">=</span> <span class="mf">0.0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to a fractional value, say 0.2, to make a cut off in&quot;</span>
              <span class="s2">&quot;the natural discrete units of positional data, viz., (pixel&quot;</span>
              <span class="s2">&quot;width, pixel height, image thickness in phi). This would then&quot;</span>
              <span class="s2">&quot;determine when the RMSD target is achieved. Only used if&quot;</span>
              <span class="s2">&quot;rmsd_cutoff = fraction_of_bin_size.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">absolute_cutoffs</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;</span>
              <span class="s2">&quot;and Phi. The units are (mm, mm, rad).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">gradient_calculation_blocksize</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reflections to use for gradient calculation.&quot;</span>
              <span class="s2">&quot;If there are more reflections than this in the manager then the&quot;</span>
              <span class="s2">&quot;minimiser must do the full calculation in blocks.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">reflections</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters used by the reflection manager&quot;</span>
  <span class="p">{</span>
    <span class="n">reflections_per_degree</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of centroids per degree of the sequence to use in&quot;</span>
              <span class="s2">&quot;refinement. The default (Auto) uses all reflections unless the&quot;</span>
              <span class="s2">&quot;dataset is wider than a single turn. Then the number of&quot;</span>
              <span class="s2">&quot;reflections may be reduced until a minimum of 100 per degree of&quot;</span>
              <span class="s2">&quot;the sequence is reached to speed up calculations. Set this to&quot;</span>
              <span class="s2">&quot;None to force use all of suitable reflections.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">minimum_sample_size</span> <span class="o">=</span> <span class="mi">1000</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;cutoff that determines whether subsetting of the input&quot;</span>
              <span class="s2">&quot;reflection list is done&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">maximum_sample_size</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of reflections to use in refinement.&quot;</span>
              <span class="s2">&quot;Overrides reflections_per_degree if that produces a larger&quot;</span>
              <span class="s2">&quot;sample size.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="mi">42</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Random seed to use when sampling to create a working set of&quot;</span>
              <span class="s2">&quot;reflections. May be int or None.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">close_to_spindle_cutoff</span> <span class="o">=</span> <span class="mf">0.02</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The inclusion criterion currently uses the volume of the&quot;</span>
              <span class="s2">&quot;parallelepiped formed by the spindle axis, the incident beam&quot;</span>
              <span class="s2">&quot;and the scattered beam. If this is lower than some value then&quot;</span>
              <span class="s2">&quot;the reflection is excluded from refinement. In detector space,&quot;</span>
              <span class="s2">&quot;these are the reflections located close to the rotation axis.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">scan_margin</span> <span class="o">=</span> <span class="mf">0.0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reflections within this value in degrees from the centre of the&quot;</span>
              <span class="s2">&quot;first or last image of the scan will be removed before&quot;</span>
              <span class="s2">&quot;refinement, unless doing so would result in too few remaining&quot;</span>
              <span class="s2">&quot;reflections. Reflections that are truncated at the scan edges&quot;</span>
              <span class="s2">&quot;have poorly-determined centroids and can bias the refined model&quot;</span>
              <span class="s2">&quot;if they are included.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">weighting_strategy</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure weighting strategy overrides&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">override</span> <span class="o">=</span> <span class="n">statistical</span> <span class="n">stills</span> <span class="n">constant</span> <span class="n">external_deltapsi</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;selection of a strategy to override default weighting&quot;</span>
                <span class="s2">&quot;behaviour&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">delpsi_constant</span> <span class="o">=</span> <span class="mi">1000000</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;used by the stills strategy to choose absolute weight value&quot;</span>
                <span class="s2">&quot;for the angular distance from Ewald sphere term of the target&quot;</span>
                <span class="s2">&quot;function, whilst the X and Y parts use statistical weights&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">constants</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">1.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;constant weights for three parts of the target function,&quot;</span>
                <span class="s2">&quot;whether the case is for stills or scans. The default gives&quot;</span>
                <span class="s2">&quot;unit weighting.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">wavelength_weight</span> <span class="o">=</span> <span class="mf">1e4</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Weight for the wavelength term in the target function for&quot;</span>
                <span class="s2">&quot;Laue refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">outlier</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection after initial reflection prediction.&quot;</span>
    <span class="p">{</span>
      <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="o">*</span><span class="n">auto</span> <span class="n">mcd</span> <span class="n">tukey</span> <span class="n">sauter_poon</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm. If auto is selected, the&quot;</span>
                <span class="s2">&quot;algorithm is chosen automatically.&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of processes over which to split outlier&quot;</span>
                <span class="s2">&quot;identification. If set to Auto, DIALS will choose&quot;</span>
                <span class="s2">&quot;automatically.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">minimum_number_of_reflections</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum number of input observations per outlier&quot;</span>
                <span class="s2">&quot;rejection job below which all reflections in the job will be&quot;</span>
                <span class="s2">&quot;rejected as potential outliers.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">separate_experiments</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, outlier rejection will be performed on each&quot;</span>
                <span class="s2">&quot;experiment separately. Otherwise, the data from all&quot;</span>
                <span class="s2">&quot;experiments will be combined for outlier rejection.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">separate_panels</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Perform outlier rejection separately for each panel of a&quot;</span>
                <span class="s2">&quot;multi- panel detector model. Otherwise data from across all&quot;</span>
                <span class="s2">&quot;panels will be combined for outlier rejection.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">separate_blocks</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, for scans outlier rejection will be performed&quot;</span>
                <span class="s2">&quot;separately in equal-width blocks of phi, controlled by the&quot;</span>
                <span class="s2">&quot;parameter outlier.block_width.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">block_width</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If separate_blocks, a scan will be divided into equal-sized&quot;</span>
                <span class="s2">&quot;blocks with width (in degrees) close to this value for&quot;</span>
                <span class="s2">&quot;outlier rejection. If Auto, a width of at least 18 degrees&quot;</span>
                <span class="s2">&quot;will be determined, such that each block contains enough&quot;</span>
                <span class="s2">&quot;reflections to perform outlier rejection.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">separate_images</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, every image will be treated separately for outlier&quot;</span>
                <span class="s2">&quot;rejection. It is a special case that will override both&quot;</span>
                <span class="s2">&quot;separate_experiments and separate_blocks, and will set these&quot;</span>
                <span class="s2">&quot;to False if required.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">tukey</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the tukey outlier rejector&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">iqr_multiplier</span> <span class="o">=</span> <span class="mf">1.5</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The IQR multiplier used to detect outliers. A value of 1.5&quot;</span>
                  <span class="s2">&quot;gives Tukey&#39;s rule for outlier detection&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">mcd</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the mcd outlier rejector, which uses an algorithm&quot;</span>
                <span class="s2">&quot;based on FAST-MCD by Rousseeuw and van Driessen. See&quot;</span>
                <span class="s2">&quot;doi.org/10.1080/00401706.1999.10485670.&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Decimal fraction controlling the size of subsets over which&quot;</span>
                  <span class="s2">&quot;the covariance matrix determinant is minimised.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">max_n_groups</span> <span class="o">=</span> <span class="mi">5</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of groups to split the dataset into if&quot;</span>
                  <span class="s2">&quot;the dataset is &#39;large&#39; (more observations than twice the&quot;</span>
                  <span class="s2">&quot;min_group_size).&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">min_group_size</span> <span class="o">=</span> <span class="mi">300</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The smallest sub-dataset size when splitting the dataset&quot;</span>
                  <span class="s2">&quot;into a number of groups, maximally max_n_groups.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_trials</span> <span class="o">=</span> <span class="mi">500</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of samples used for initial estimates to seed&quot;</span>
                  <span class="s2">&quot;the search within each sub-dataset.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of concentration steps to take after initial&quot;</span>
                  <span class="s2">&quot;estimates.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;large&#39;, the number of concentration&quot;</span>
                  <span class="s2">&quot;steps to take after applying the best subset estimates to&quot;</span>
                  <span class="s2">&quot;the merged group.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="mi">100</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;small&#39;, the number of concentration&quot;</span>
                  <span class="s2">&quot;steps to take after selecting the best of the initial&quot;</span>
                  <span class="s2">&quot;estimates, applied to the whole dataset.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">threshold_probability</span> <span class="o">=</span> <span class="mf">0.975</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Quantile probability from the Chi-squared distribution with&quot;</span>
                  <span class="s2">&quot;number of degrees of freedom equal to the number of&quot;</span>
                  <span class="s2">&quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;</span>
                  <span class="s2">&quot;residuals). Observations whose robust Mahalanobis distances&quot;</span>
                  <span class="s2">&quot;are larger than the obtained quantile will be flagged as&quot;</span>
                  <span class="s2">&quot;outliers.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">sauter_poon</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;</span>
                <span class="s2">&quot;(2010) (https://doi.org/10.1107/S0021889810010782)&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">px_sz</span> <span class="o">=</span> <span class="n">Auto</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;X, Y pixel size in mm. If Auto, this will be taken from the&quot;</span>
                  <span class="s2">&quot;first panel of the first experiment.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Verbose output.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Output file name for making graphs of |dr| vs spot number&quot;</span>
                  <span class="s2">&quot;and dy vs dx.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">experiments</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">expt</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
  <span class="n">reflections</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">refl</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
  <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">log</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><!--<h3>Navigation</h3>-->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">How-to</a></li>
<li class="toctree-l1"><a class="reference external" href="https://dials.github.io/kb">Knowledge Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workshops/index.html">Workshops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../national_resource.html">US National Resource</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../projects.html">Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer container">
  <a href="https://www.diamond.ac.uk/"><img class="logofooter" alt="Diamond" src="../../_static/diamond_logo.png" /></a>
  <a href="https://www.ccp4.ac.uk/"><img class="logofooter" alt="CCP4" src="../../_static/CCP4-logo-plain.png" /></a>
  <a href="https://www.stfc.ac.uk/"><img class="logofooter" alt="STFC" src="https://dials.github.io/images/logos/ukri-stfc.png" /></a>
  <a href="https://www.lbl.gov/"><img class="logofooter" alt="LBL" src="https://dials.github.io/images/logos/lbl.png" /></a>
  <a href="http://smb.slac.stanford.edu/"><img class="logofooter" alt="SSRL/SMB" src="https://dials.github.io/images/logos/smbssrl.jpg" /></a>
  </div>

  <script type="text/javascript">
     $(document).ready(function() {
         $(".toggle > *").hide();
         $(".toggle .header").show();
         $(".toggle .header").click(function() {
             $(this).parent().children().not(".header").toggle(400);
             $(this).parent().children(".header").toggleClass("open");
         })
     });
  </script>
  
    <div class="footer">
      &#169;2025, Diamond Light Source, Lawrence Berkeley National Laboratory and STFC.
      
    </div>

    

    

  </body>
</html>